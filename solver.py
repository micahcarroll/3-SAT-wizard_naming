# This Python file uses the following encoding: utf-8
import argparse
import random
import pycosat
import randomized3SAT

DEBUG = False

"""
======================================================================
  Complete the following function.
======================================================================
"""

class Wiz(object):
    # Wizard Manager
    # Each wizard is encoded into a two digit number

    def __init__(self, wizards):
        self.list = wizards
        self.wizard_encoder, self.wizard_decoder = self.create_encoder_decoder(wizards)
        self.encoded_list = self.encode_multiple(wizards)

    def create_encoder_decoder(self, wizards):
        # The encoder starts at 10
        encoder = {}
        decoder = {}
        for i in range(len(self.list)):
            ith_wizard = self.list[i]
            encoding_index = i + 10
            encoder[ith_wizard] = encoding_index
            decoder[encoding_index] = ith_wizard
        return encoder, decoder

    def encode(self, name):
        return self.wizard_encoder[name]

    def decode(self, number):
        return self.wizard_decoder[number]

    def encode_multiple(self, wizard_list):
        return [self.encode(w) for w in wizard_list]

    def decode_multiple(self, wizard_list):
        return [self.decode(w) for w in wizard_list]


class Constraints(object):
    """
    Constraint converter to prepare constraints to be inputted to
    the pycosat library. 

    Each instance is a constraint of the form [a b c d]
    "a or b or c or d"
    """
    def __init__(self, constraint, wiz):
        self.wiz = wiz
        self.list = constraint
        self.encoded = wiz.encode_multiple(constraint)

    def get_all_sat_constraints(wiz, constraints, sat2=False):
        constraints_2_terms = []

        for constraint in constraints:
            if constraint == []: return
            double_constraint = Constraint(constraint, wiz).convert()
            constraints_2_terms.extend(double_constraint) # prevent duplicates

        if sat2:
            return constraints_2_terms

        return constraints_2_terms + Constraints.generate_3_term_constraints(wiz)

    def generate_3_term_constraints(wiz):
        # Possible combinations:
        # 12 + 13 + 23  |  12 + 13 + ¬23  |  12 + ¬13 + ¬23 
        # ¬12 + 13 + 23  |  ¬12 + ¬13 + 23  |  ¬12 + ¬13 + ¬23

        # Invalid combinations
        # 12 + ¬13 + 23  |  ¬12 + 13 + ¬23
        wizards = wiz.encoded_list
        constraints = []

        for i in wizards:
            for j in wizards:
                for k in wizards:
                    if i < j < k:
                        c12 = int(str(i) + str(j))
                        c13 = int(str(i) + str(k))
                        c23 = int(str(j) + str(k))

                        not_allowed = [c12, -c13, c23]
                        not_allowed_reverse = [-c12, c13, -c23]
                        constraints.append(not_allowed)
                        constraints.append(not_allowed_reverse)

        return constraints

class Constraint(object):
    def __init__(self, constraint, wiz):
        self.wiz = wiz
        self.list = constraint
        self.encoded = wiz.encode_multiple(constraint)
    
    def convert(self):
        """
        For each constraint "m not btw a and b" return a constraint 
        of the form (a < m or b > m) and (b < m or a > m).

        input constraints will be of the form ["a", "b", "m"]
        as example, this could be equivalent to [10, 14, 15] (once encoded)
        output constraints should be of the form [[1015, -1415], [1415, -1015]]
        Note that each pair of clauses generated by a constraint is just the
        reverse of each other.
        """
        sat_constraint = []
        a, b, m = self.list
        first, second, middle = self.encoded

        # write a < m
        if first < middle:
            str_encoded = str(first) + str(middle)
            sat_constraint.append(int(str_encoded))
        else:
            str_encoded = str(middle) + str(first)
            sat_constraint.append(-int(str_encoded))

        # write b > m
        if middle < second:
            str_encoded = str(middle) + str(second)
            sat_constraint.append(int(str_encoded))
        else:
            str_encoded = str(second) + str(middle)
            sat_constraint.append(-int(str_encoded))

        # AND the reverse
        reverse_constraint = [-x for x in sat_constraint]

        return sat_constraint, reverse_constraint

class Variables(object):
    """
    Stores variable assignment returned by 2SAT and
    returns useful information for further manipulation
    """
    def __init__(self, sat_solution, wiz):
        self.wiz = wiz
        self.list = self.populate(sat_solution)

    def __iter__(self):
        for var in self.list:
            yield var.num

    def populate(self, sat_solution):
        """
        Populates variable list
        """
        variable_list = []
        for number in sat_solution:
            if len(Variable.clean(number)) == 4:
                var = Variable(number)
                if var.first_half < var.second_half and var.first_half in self.wiz.wizard_decoder and var.second_half in self.wiz.wizard_decoder:
                    variable_list.append(var)
        return variable_list

    def involving_enc(self, x):
        # Returns a list of all variables involving a
        lst = []
        for var in self.list:
            a = var.first_half
            b = var.second_half

            if (a == x or b == x) and (a < b):
                lst.append(var)
        return lst

    def between(self, x, y):
        if x < y:
            code = int(str(x) + str(y))
        else:
            code = int(str(y) + str(x))

        if code in self:
            return code
        elif -code in self:
            return -code
        else:
            return None

    def between_decoded(self, x, y):
        result = Variable(self.between(x, y))
        v = str(result)
        s = " smaller "
        if str(v[0]) == '-':
            s = " larger "

        first = self.wiz.decode(result.first_half)
        second = self.wiz.decode(result.second_half)
        #print(first + " is" + s + "than " + second)
        return [first, s, second]

    def smaller_than_enc(self, a, b):
        # i.e. "before"
        if a < b:
            if int(str(a) + str(b)) in self:
                return True
        else:
            if -int(str(b) + str(a)) in self:
                return True
        return False

    def larger_than_enc(self, a, b):
        return not self.smaller_than_enc(a, b)

    def smaller_than_name(self, name_1, name_2):
        a = self.wiz.encode(name_1)
        b = self.wiz.encode(name_2)
        return self.smaller_than_enc(a, b)

    def larger_than_name(self, name_1, name_2):
        return not self.smaller_than_name(name_1, name_2)

class Variable(object):
    def __init__(self, num):
        self.num = num
        self.first_half, self.second_half = self.decompose()

    def __bool__(self):
        return self.num > 0
    __nonzero__=__bool__

    def clean(number):
        if str(number)[0] == '-':
            return str(number)[1:]
        return str(number)

    def decompose(self):
        v = Variable.clean(self.num)
        if len(v) != 4:
            print("ERROR")
        return int(str(v)[:2]), int(str(v)[2:])

    def switch(self):
        self.num = -self.num 

class OrderWizards(object):
    # Searches for ordering of wizards that satisfies the Variables
    def __init__(self, var, wiz):
        self.var = var
        self.wiz = wiz

    def naive_search(self, constraints):
        solution = []

        for wizard in self.wiz.encoded_list:
            target_index = 0

            for i in range(len(solution)):
                ith_solution_wizard = solution[i]

                if self.var.larger_than_enc(wizard, ith_solution_wizard):
                    if DEBUG:
                        print(self.wiz.decode(wizard) + " is larger than " +
                            self.wiz.decode(ith_solution_wizard) + " at index " + str(i))
                    target_index = i + 1

            if DEBUG:
                print("Inserting " + self.wiz.decode(wizard) +
                 " at index " + str(target_index))

            solution.insert(target_index, wizard)

            if DEBUG:
                print(self.wiz.decode_multiple(solution))

            if check_for_non_valid_constraint(self.wiz.decode_multiple(solution), constraints) is not None:
                pass

        return solution


def solve(num_wizards, num_constraints, wizards, constraints, sat2=False):
    """
    Write your algorithm here.
    Input:
        num_wizards: Number of wizards
        num_constraints: Number of constraints
        wizards: An array of wizard names, in no particular order
        constraints: A 2D-array of constraints, 
                     where constraints[0] may take the form ['A', 'B', 'C']

    Output:
        An array of wizard names in the ordering your algorithm returns
    """
    random.shuffle(wizards)
    wiz = Wiz(wizards)
    sat_constraints = Constraints.get_all_sat_constraints(wiz, constraints, sat2)

    sat_solution2 = pycosat.solve(sat_constraints)
    sat_solution = randomized3SAT.schoningRandomized3SAT(sat_constraints)

    var = Variables(sat_solution, wiz)
    var2 = Variables(sat_solution2, wiz)
    search = OrderWizards(var, wiz)
    search2 = OrderWizards(var2, wiz)
    result = wiz.decode_multiple(search2.naive_search(constraints))
    if DEBUG:
        print(result)
    errors = check_for_non_valid_constraint(result, constraints)
    if errors is None and DEBUG:
        print("CHECK PASSED!")
    if errors:
        print("An error was found")

    return result, errors


def check_for_non_valid_constraint(ordering, constraints):
    node_map = {k: v for v, k in enumerate(ordering)}
    errors = []
    count = 0

    for constraint in constraints:
        a = constraint[0]
        b = constraint[1]
        m = constraint[2]
        if not (a in node_map and b in node_map and m in node_map):
            continue

        wiz_a = node_map[a]
        wiz_b = node_map[b]
        wiz_mid = node_map[m]

        if (wiz_a < wiz_mid < wiz_b) or (wiz_b < wiz_mid < wiz_a):
            #print("{} was found between {} and {}".format(
            #    constraint[2], constraint[0], constraint[1]))
            errors.append((wiz_a, wiz_b, wiz_mid))
            count += 1

    if errors and DEBUG:
        print(str(count) + " Errors found!")
        return errors
    else:
        return None

"""
======================================================================
   No need to change any code below this line
======================================================================
"""

def read_input(filename):
    with open(filename) as f:
        num_wizards = int(f.readline())
        solution = f.readline().split()
        num_constraints = int(f.readline())
        constraints = []
        wizards = set()
        for _ in range(num_constraints):
            c = f.readline().split()
            constraints.append(c)
            for w in c:
                wizards.add(w)

    wizards = list(wizards)
    return num_wizards, num_constraints, wizards, constraints


def write_output(filename, solution):
    with open(filename, "w") as f:
        for wizard in solution:
            f.write("{0} ".format(wizard))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Constraint Solver.")
    parser.add_argument("input_file", type=str, help="___.in")
    parser.add_argument("output_file", type=str, help="___.out")
    parser.add_argument("debug", type=str, help="debug")
    args = parser.parse_args()

    if args.debug == "-d":
        DEBUG = True

    num_wizards, num_constraints, wizards, constraints = read_input(args.input_file)
    solution = solve(num_wizards, num_constraints, wizards, constraints)
    write_output(args.output_file, solution)